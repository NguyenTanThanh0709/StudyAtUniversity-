# -*- coding: utf-8 -*-
"""lab07.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dGYGPhF0mfeexDf1uGRvd4dl53kHAUGT
"""

import numpy as np
u1 = np.array([3,1,1])
u2 = np.array([-1,2,1])
u3 = np.array([-1/2,2,7/2])

inner_prod1 = sum(u1*u2)
inner_prod2 = sum(u1*u3)
inner_prod3 = sum(u2*u3)
print(inner_prod1)
print(inner_prod2)
print(inner_prod3)



import numpy as np
u1 = np.array([7,6])
u2 = np.array([4,2])

def proj(u1, u2):
    u1 = u1/np.linalg.norm(u1)
    u2 = u2/np.linalg.norm(u2)
    return np.dot(u1, u2)

def proj1(u1,u2):
    return sum(u1*u2)/sum(u2**2)*sum(u2)

print(proj(u1,u2))
print(proj1(u1,u2))

import numpy as np

U = np.array([[0,1,0,0],[0,0,0,1],[1,0,0,0],[0,0,1,0]])

def checkThatHasOrthonormalColums(U):
    for i in range(len(U)):
        for j in range(len(U)):
            if i == j:
                continue
            else:
                if np.dot(U[i],U[j]) != 0:
                    return False
    return True

print(checkThatHasOrthonormalColums(U))

import numpy as np

A = np.array([[-10,13,7,-11],[2,1,-5,3],[-6,3,13,-3],[16,-16,-2,5],[2,1,-5,-7]])

def proj(u,v):
  return sum(u*v)/sum(v*v)

V= np.zeros((A.shape))
V[:,0] = A[:,0]

print(V)
for i in range(1,A.shape[1]):
  pv = 0
  for j in range(0,i):
    pv += proj(A[:,i],A[:,j])
  V[:,i] = np.round(A[:,i-1]-pv)

print(V)

from sympy import *
import numpy as np
C = Matrix(np.array([[1,0,2,3],[4,-1,0,2],[0,-1,-8,10]]))
def aBasisForTheCol(C):
    c, pivot = Matrix.rref(C)
    print(c[:,pivot])
    #print(c[pivot,:])
    print(pivot)

def aBasisForTheRow(C):
    c, pivot = Matrix.rref(C)
    print(c[pivot,:])
    print(pivot)

import numpy as np
def rank(v1,v2,v3,w):
  rank1 = np.linalg.matrix_rank([v1,v2,v3])
  rank2 = np.linalg.matrix_rank([v1,v2,v3,w])

  if rank1 == rank2:
    print("W is a linear comnination of v1, v2 ,v3")
  else:
    print("W is not a linear comnination of v1, v2 ,v3")

v1 = np.array([1,2,3,4])
v2 = np.array([-1,0,1,3])
v3 = np.array([0,5,-6,8])

w = np.array([3,-6,17,11])

rank(v1,v2,v3,w)

v1 = np.array([1,1,2,2])
v2 = np.array([2,3,5,6])
v3 = np.array([2,-1,3,6])

w = np.array([0,5,3,0])

rank(v1,v2,v3,w)

from sympy import *
import numpy as np

A2 = Matrix(np.array([[1,0,2,3],[4,-1,0,2],[0,-1,-8,10]]))
null = Matrix.nullspace(A2)
n = np.array(null).T
print(n)

v1= n[:,0]
v2 = n[:,1]

print(v1, "\n", v2)

print(A2@n)

# import numpy as np
# from sympy import *

# w = np.array([1,1,-1,-1,-3])
# A = np.array([[7,6,-4,1],[-5,-1,0,-2],[9,-11,7,-3],[19,-9,7,1]])

# print(A@w)
# #ex11 scipy.linalg.hilbert

# import sympy 
from sympy import * 
  
M = Matrix(np.array([[7,6,-4,1],[-5,-1,0,-2],[9,-11,7,-3],[19,-9,7,1]]))
#print("Matrix : {} ".format(M))
   
# Use sympy.nullspace() method 
M_nullspace = M.nullspace() *  np.array([1,1,-1,-1,-3])
print(M.nullspace() )
print(M.columnspace())
      
#print("Nullspace of a matrix : {}".format(M_nullspace))

from scipy.linalg import hilbert
from scipy.linalg import pascal

import numpy as np
from sympy import *

print(hilbert(5))

print(pascal(5))

# print(magic(5))

def rows(square, magic_num):
    n = len(square)
    for i in range(n):
        sum_row = 0
        for j in range(n):
            sum_row += square[i][j]
        if sum_row != magic_num:
            return False
    return True
def columns(square, magic_num):
    n = len(square)
    for i in range(n):
        sum_col = 0
        for j in range(n):
            sum_col += square[j][i]
        if sum_col != magic_num:
            return False
    return True
def diagonals(square, magic_num):
    n = len(square)
    #left_to_right
    sum_diag = 0
    for i in range(n):
        sum_diag += square[i][i]
    if sum_diag != magic_num:
        return False
    #right to left
    sum_diag = 0
    for i in range(n):
        sum_diag += square[i][-(i+1)]
    return sum_diag == magic_num
# this is our main function
def magic_square(square):
    # find magic number
    magic_constant = 0
    for n in square[0]:
        magic_constant += n
    return ( rows(square, magic_constant) and columns(square, magic_constant) and diagonals(square, magic_constant) )

sq = [[0,2,4,6], 
[6,6,0,0], 
[1,1,5,5], 
[5,3,3,1]]
magic_square(sq)

# import numpy as np
# from sympy import *

# vectorA1 = np.array([1,-2,0]).T
# vectorA2 = np.array([0,-4,1]).T
# vectorA3 = np.array([1,-1,1]).T
# print(vectorA1)
# print(vectorA2)
# print(vectorA3)

# Import Numpy library
import numpy as np
# Define three column vectors
v = np.array([1,-2,0]).reshape(-1,1)
u = np.array([0,-4,1]).reshape(-1,1)
w = np.array([1,-1,1]).reshape(-1,1)
# Check the linear dependency with writing the equality
print() np.all(w == 2*v+u))