# -*- coding: utf-8 -*-
"""52100841_NguyenTanThanh_lab09_10.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10huo83LDTAs_psilQlKNeE-DeFazJU5H

# **Exercise 1:**
"""

import scipy.io
import os
import matplotlib.pyplot  as plt
import numpy as np


os.getcwd() # thu muc hien tai
# os.chdir("/content/drive/My Drive/ColabNottebooks/")
data = scipy.io.loadmat('./data.mat')

def load_ghost(plt,P,le,re,m,xt,yt,c_p,c_e,c_m,c_t,text):
    plt.plot(P[0, :], P[1, :],c_p)
    plt.plot(le[0, :], le[1, :],c_e)
    plt.plot(re[0, :], re[1, :],c_e)
    plt.plot(m[0, :], m[1, :],c_m)
    # plt.plot(xt, yt,c_t)
    # plt.text(xt, yt, text, fontsize=14, color=c_t)
    plt.plot(xt,yt,text, bbox = dict(facecolor=c_t, alpha=0.8))

# draw
# fig = plt.figure()
# ax = fig.add_subplot(111)
# ax.patch.set_facecolor('pink')
# plt = load_ghost(plt,data['P'],data['le'],data['re'],data['m'],data['xt'],data['yt'],data['c_p'],data['c_e'],data['c_m'],data['c_t'])

# plt.xlim(0, 1)
# plt.ylim(0, 1)

# plt.grid()
# plt.show()


def basic_translation(P,dx,dy):
    P_t = P.copy()
    P_t[0, :] = P[0, :] + dx
    P_t[1, :] = P[1, :] + dy
    return P_t

def translation(P,le,re,m,xt,yt):
    dx = 20
    dy = 0
    P_t = basic_translation(P,dx,dy)
    le_t = basic_translation(le,dx,dy)
    re_t = basic_translation(re,dx,dy)
    m_t = basic_translation(m,dx,dy)
    xt_t = xt + dx
    yt_t = yt + dy
    return P_t,le_t,re_t,m_t,xt_t,yt_t

def basic_shearing(P,sx,sy):
    M = np.array([[1,sx,0],[sy,1,0],[0,0,1]])
    Ps = np.zeros((P.shape), dtype=np.float32)
    for i in range(P.shape[1]):
        Pc = [P[0,i], P[1,i]]@M
        Ps[0,i] = Pc[0]
        Ps[1,i] = Pc[1]
    return Ps

def shearing(P,le,re,m,xt,yt):
    sx = 0.5
    sy = 0
    Ps = basic_shearing(P,sx,sy)
    le_s = basic_shearing(le,sx,sy)
    re_s = basic_shearing(re,sx,sy)
    m_s = basic_shearing(m,sx,sy)
    xt_s = xt
    yt_s = yt
    return Ps,le_s,re_s,m_s,xt_s,yt_s

def basic_scaling(P,sx,sy):
    M = np.array([[sx,0,0],[0,sy,0],[0,0,1]])
    Ps = np.zeros((P.shape), dtype=np.float32)
    for i in range(P.shape[1]):
        Pc = [P[0,i], P[1,i]]@M
        Ps[0,i] = Pc[0]
        Ps[1,i] = Pc[1]
    return Ps

def scaling(P,le,re,m,xt,yt):
    sx = 0.5
    sy = 0.5
    Ps = basic_scaling(P,sx,sy)
    le_s = basic_scaling(le,sx,sy)
    re_s = basic_scaling(re,sx,sy)
    m_s = basic_scaling(m,sx,sy)
    xt_s = xt
    yt_s = yt
    return Ps,le_s,re_s,m_s,xt_s,yt_s

def basic_reflection(P):
    M = np.array([[-1,0,0],[0,1,0],[0,0,1]])
    Ps = np.zeros((P.shape), dtype=np.float32)
    for i in range(P.shape[1]):
        Pc = [P[0,i], P[1,i]]@M
        Ps[0,i] = Pc[0]
        Ps[1,i] = Pc[1]
    return Ps

def reflection(P,le,re,m,xt,yt):
    Ps = basic_reflection(P)
    le_r = basic_reflection(le)
    re_r = basic_reflection(re)
    m_r = basic_reflection(m)
    xt_r = xt
    yt_r = yt
    return Ps,le_r,re_r,m_r,xt_r,yt_r

def basic_rotation(P,alpha):
    M = np.array([[np.cos(alpha),-np.sin(alpha),0],[np.sin(alpha),np.cos(alpha),0],[0,0,1]])
    Ps = np.zeros((P.shape), dtype=np.float32)
    for i in range(P.shape[1]):
        Pc = [P[0,i], P[1,i]]@M
        Ps[0,i] = Pc[0]
        Ps[1,i] = Pc[1]
    return Ps

def rotation(P,le,re,m,xt,yt):
    alpha = np.pi/4
    Ps = basic_rotation(P,alpha)
    le_r = basic_rotation(le,alpha)
    re_r = basic_rotation(re,alpha)
    m_r = basic_rotation(m,alpha)
    xt_r = xt
    yt_r = yt
    return Ps,le_r,re_r,m_r,xt_r,yt_r




# draw

fig = plt.figure()
ax = fig.add_subplot(111)
ax.patch.set_facecolor('pink')

load_ghost(plt,data['P'],data['le'],data['re'],data['m'],data['xt'],data['yt'],data['c_p'],data['c_e'],data['c_m'],data['c_t'],data['text'])

# affine transformation
P_t,le_t,re_t,m_t,xt_t,yt_t = translation(data['P'],data['le'],data['re'],data['m'],data['xt'],data['yt'])
load_ghost(plt,P_t,le_t,re_t,m_t,xt_t,yt_t,data['c_p'],data['c_e'],data['c_m'],data['c_t'],data['text'])

# shearing
Ps_t,le_s,re_s,m_s,xt_s,yt_s = shearing(data['P'],data['le'],data['re'],data['m'],data['xt'],data['yt'])
load_ghost(plt,Ps_t,le_s,re_s,m_s,xt_s,yt_s,data['c_p'],data['c_e'],data['c_m'],data['c_t'],data['text'])

# scaling
Ps_s,le_s,re_s,m_s,xt_s,yt_s = scaling(data['P'],data['le'],data['re'],data['m'],data['xt'],data['yt'])
load_ghost(plt,Ps_s,le_s,re_s,m_s,xt_s,yt_s,data['c_p'],data['c_e'],data['c_m'],data['c_t'],data['text'])

# reflection
Ps_r,le_r,re_r,m_r,xt_r,yt_r = reflection(data['P'],data['le'],data['re'],data['m'],data['xt'],data['yt'])
load_ghost(plt,Ps_r,le_r,re_r,m_r,xt_r,yt_r,data['c_p'],data['c_e'],data['c_m'],data['c_t'],data['text'])

# rotation
Ps_r,le_r,re_r,m_r,xt_r,yt_r = rotation(data['P'],data['le'],data['re'],data['m'],data['xt'],data['yt'])
load_ghost(plt,Ps_r,le_r,re_r,m_r,xt_r,yt_r,data['c_p'],data['c_e'],data['c_m'],data['c_t'],data['text'])





# load
plt.xlim(0, 1)
plt.ylim(0, 1)

plt.grid()
plt.show()

from google.colab.patches import cv2_imshow
import numpy as np
from PIL import Image

im = Image.open('testdata/test.jpg')
plt.imshow(im)
im_g = np.asanyarray(im)

U, S, V  = np.linalg.svd(im_g,full_matrices=True)
s = np.diag(S)

for r in range(2,200,50):
    R = U[:,:r] @ s[:r,:r] @ V[:r,:]
    plt.imshow(R,cmap = 'gray')
    plt.title('r = ' + str(r))
    plt.plot()
    plt.pause(0.01)
    plt.clf()
    R = R.astype(np.uint8)
    compressed_image = Image.fromarray(R)
    compressed_image.save('testdata/compressed_image_' + str(r) + '.jpg')

import matplotlib.pyplot  as plt
import numpy as np

import numpy as np
import matplotlib.pyplot as plt

def findTheEigenvalues(A):
    """
    Finds the eigenvalues of a matrix A
    """
    eigenvalues = []
    for i in range(len(A)):
        eigenvalues.append(A[i][i])
    return eigenvalues

def computeDeterminantBasedOnEigenvalues(eigenvalues):
    """
    Computes the determinant of a matrix based on its eigenvalues
    """
    determinant = 1
    for i in range(len(eigenvalues)):
        determinant *= eigenvalues[i]
    return determinant

A = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
eigenvalues = findTheEigenvalues(A)
determinant = computeDeterminantBasedOnEigenvalues(eigenvalues)
print("The determinant of the matrix A is:", determinant)

import numpy as np

A1 = np.array([[1,0],[0,3]])

def FindTheSingularValue(A):
    # Find the singular value of a matrix
    # A: a matrix
    # return: the singular value of A
    U,S,V = np.linalg.svd(A)
    return S[0]

import numpy as np

A1 = np.array([[-18,13,-4,4],[2,3,5,-5],[1,4,-5,6],[3,4,5,4]])



def computeSVD(A):
    # Compute the SVD of a matrix
    # A: a matrix
    # return: U,S,V
    U,S,V = np.linalg.svd(A)
    return U,S,V

import numpy as np
import cv2

img = cv2.imread('lena.jpg')

cv2.imshow('original', img)
cv2.waitKey(0)

import numpy as np
from sympy import *
A = np.array([[2,2],[2,3]])
b = np.array([[4],[6]])
x = np.linalg.solve(A.T.dot(A),A.T.dot(b))
print(x)

"""# **Exercise 2:**"""

import numpy as np
from sympy import *
A2 = np.array([[0, 0, 1],[0, 1, 1],[1,2,1],[1,0,1],[4,1,1],[4,2,1]])
b2 = np.array([[0.5],[1.6],[2.8],[0.8],[5.1],[5.9]])
x2 = np.linalg.solve(A2.T.dot(A2),A2.T.dot(b2))
print("c = {}, d = {}, e = {}".format(x2[0],x2[1],x2[2]))

"""# **Exercise 3:**"""

import numpy as np
from sympy import *
from matplotlib import pyplot as plt
x = symbols('x')
def solve3(x0,y0,x1,y1,x2,y2,x3,y3,x4,y4):
  print("Cach 1:")
  A3 = np.array([[0,1],[1,1],[2,2],[3,2]])
  sa3 = A3.shape # [4,2]
  # print(sa3)
  n = sa3[0] # n = 4
  x_tb = 0
  y_tb = 0
  for i in range(n):
      #print(A3[i,0],A3[i,1])
      x_tb = x_tb + A3[i,0]  # 0 + 1 + 2 + 3 = 6
      y_tb = y_tb + A3[i,1]  # 1 + 1 + 2 + 2 = 6
  x_tb =x_tb/n #6/4 = 1.5
  y_tb =y_tb/n #6/4 = 1.5
  m1 = 0
  m2 = 0
  for i in range(n):
      m1 = m1 + (A3[i,0] - x_tb)*(A3[i,1] - y_tb)
      m2 = m2 + (A3[i,0] - x_tb)*(A3[i,0] - x_tb)
  m = m1/m2
  #print("m = ",m)
  b = y_tb - m*x_tb
  # In PT duong thang can tim y = mx + b

  y = m*x + b
  print("y = ",y)

  print("\n----------------------------------\n")
  #Cach 2
  print("Cach 2")
  A3a = np.array([[1,0],[1,1],[1,2],[1,3]])
  b3a = np.array([1,1,2,2])
  A3aT = A3a.T
  A3aTA = A3aT.dot(A3a)
  A3aTb = A3aT.dot(b3a)
  x1a = np.linalg.solve(A3aTA,A3aTb)
  print("x = ",x1a)
  y1a = x1a[0] + x1a[1]*x
  print("y = ",y1a)

  # Ve do thi mo phong

  x1 = np.arange(0,4,0.01)
  y1 = m*x1 + b
  plt.plot(x1, y1, color='red')
  plt.plot(0, 1, 'ko',color='green')
  plt.plot(1, 1, 'ko',color='green')
  plt.plot(2, 2, 'ko',color='green')
  plt.plot(3, 2, 'ko',color='green')

import numpy as np
from sympy import *
from matplotlib import pyplot as plt
x = symbols('x')
def solve3(x1,y1,x2,y2,x3,y3,x4,y4):
    print("Cach 1:")
    A3 = np.array([[x1,y1],[x2,y2],[x3,y3],[x4,y4]])
    sa3 = A3.shape # [4,2]
    # print(sa3)
    n = sa3[0] # n = 4
    x_tb = 0
    y_tb = 0
    for i in range(n):
        #print(A3[i,0],A3[i,1])
        x_tb = x_tb + A3[i,0]  # 0 + 1 + 2 + 3 = 6
        y_tb = y_tb + A3[i,1]  # 1 + 1 + 2 + 2 = 6
    x_tb =x_tb/n #6/4 = 1.5
    y_tb =y_tb/n #6/4 = 1.5
    m1 = 0
    m2 = 0
    for i in range(n):
        m1 = m1 + (A3[i,0] - x_tb)*(A3[i,1] - y_tb)
        m2 = m2 + (A3[i,0] - x_tb)*(A3[i,0] - x_tb)
    m = m1/m2
    #print("m = ",m)
    b = y_tb - m*x_tb
    # In PT duong thang can tim y = mx + b

    y = m*x + b
    print("y = ",y)

    print("\n----------------------------------\n")
    #Cach 2
    print("Cach 2")
    A3a = np.array([[1,x1],[1,x2],[1,x3],[1,x4]])
    b3a = np.array([y1,y2,y3,y4])
    A3aT = A3a.T
    A3aTA = A3aT.dot(A3a)
    A3aTb = A3aT.dot(b3a)
    x1a = np.linalg.solve(A3aTA,A3aTb)
    print("x = ",x1a)
    y1a = x1a[0] + x1a[1]*x
    print("y = ",y1a)

    # Ve do thi mo phong

    x_plot = np.arange(x1,x4+1,0.01)
    y_plot = m*x_plot + b
    plt.plot(x_plot, y_plot, color='c')
    plt.plot(x1, y1, 'ko',color='green')
    plt.plot(x2, y2, 'ko',color='green')
    plt.plot(x3, y3, 'ko',color='green')
    plt.plot(x4, y4, 'ko',color='green')
    plt.show()

print("CÂU A")
solve3(0,1,1,1,2,2,3,2)
print("\n---------------------------\n")
print("CÂU B")
solve3(1,0,2,1,4,2,5,3)
print("\n---------------------------\n")
print("CÂU C")
solve3(-1,0,0,1,1,2,2,4)
print("\n---------------------------\n")
print("CÂU D")
solve3(2,3,3,2,5,1,6,0)

"""# **Exercise 4:**"""

import numpy as np
from matplotlib import pyplot as plt
from sympy import *

A4 = np.array([[2,1],[6,1],[20,1],[30,1],[40,1]])
b4 = np.array([20,18,10,6,2])

#least square solution find u = x4 = (a,b)
A4t = np.transpose(A4)
A4tA = A4t.dot(A4)
A4tA_1 = np.linalg.inv(A4tA)
A4tb4 = A4t.dot(b4)
x4 = A4tA_1.dot(A4tb4)
print("x4 = ",x4)
# Tim ham so y = ax + b
x = Symbol('x')
y4 = round(x4[0],2)*x + round(x4[1],2)
print("y = ",y4)

#Ve do thi ham so
x1 = np.arange(0,45,0.01)
y4p = round(x4[0],2)*x1 + round(x4[1],2)
plt.plot(x1, y4p, color='blue')

plt.plot(2, 20, 'ko', color='red')
plt.plot(6, 18, 'ko', color='red')
plt.plot(20, 10, 'ko', color='red')
plt.plot(30, 6, 'ko', color='red')
plt.plot(40, 2, 'ko', color='red')
plt.show()

"""# **Exercise 5:**"""

import numpy as np
from matplotlib import pyplot as plt
from sympy import *

A5 = np.array([[cos(1),sin(1)],[cos(2),sin(2)],[cos(3),sin(3)]],float)
b5 = np.array([7.9,5.4,-9])

#least square solution find u = x4 = (a,b)
A5t = np.transpose(A5)
A5tA = A5t.dot(A5)
A5tA_1 = np.linalg.inv(A5tA)
A5tb5 = A5t.dot(b5)
x5 = A5tA_1.dot(A5tb5)
print("x5 = ",x5)
# Tim ham so y = ax + b
x = Symbol('x')
y5 = round(x5[0],2)*x + round(x5[1],2)
print("y = ",y5)

#Ve do thi ham so
x1 = np.arange(0,5,0.01)
y5p = round(x5[0],2)*np.cos(x1) + round(x5[1],2)*np.sin(x1)
plt.plot(x1, y5p, color='m')

plt.plot(1, 7.9, 'ko', color='b')
plt.plot(2, 5.4, 'ko', color='b')
plt.plot(3, -9, 'ko', color='b')
plt.show()

"""# **Exercise 6:**"""

import numpy as np
A6 = np.array([[1,1,1,1],[8,4,2,1],[27,9,3,1],[64,16,4,1],[125,25,5,1],[6**3,36,6,1]])
b6 = np.array([2.1,3.5,4.2,3.1,4.4,6.8])

A6t = np.transpose(A6)
A6tA = A6t.dot(A6)
A6tA_1 = np.linalg.inv(A6tA)
A6tb6 = A6t.dot(b6)
x6 = A6tA_1.dot(A6tb6)

y6 = x6[0]*x**3 + x6[1]*x**2 + x6[2]*x + x6[3]
print("y = ", y6)

x61 = np.arange(0,7,0.01)
y61 = x6[0]*x61**3 + x6[1]*x61**2 + x6[2]*x61 + x6[3]
plt.plot(x61, y61, color='green')

plt.plot(1, 2.1, 'ko', color='red')
plt.plot(2, 3.5, 'ko', color='red')
plt.plot(3, 4.2, 'ko', color='red')
plt.plot(4, 3.1, 'ko', color='red')
plt.plot(5, 4.4, 'ko', color='red')
plt.plot(6, 6.8, 'ko', color='red')
plt.show()

"""# **Exercise 7:**"""

import numpy as np
from matplotlib import pyplot as plt
from sympy import *
def Slu(A,l,u):
    S = np.array([[l,0],[0,u]])
    return S.dot(A)


def plotGraph(x1,y1,x2,y2):
    plt.plot(x1,y1,'ko',color = 'c')
    plt.plot(x2,y2,'ko',color = 'g')
    plt.grid()
    plt.show()


A7 = np.array([[3],[-2]])
B7 = np.array([[-1],[1]])

print("Câu a: Slu with l = 2 and u = 2")
print(Slu(A7,2,2))
S1a = Slu(A7,2,2)
plotGraph(A7[0],A7[1],S1a[0],S1a[1])

print("----------")

print(Slu(B7,2,2))
S2a = Slu(B7,2,2)
plotGraph(A7[0],A7[1],S2a[0],S2a[1])

print("\nCâu b: Slu with l = 0.5 and u = 0.5")
print(Slu(A7,0.5,0.5))
S1b = Slu(A7,0.5,0.5)
plotGraph(A7[0],A7[1],S1b[0],S1b[1])

print("----------")

print(Slu(B7,0.5,0.5))
S2b = Slu(B7,0.5,0.5)
plotGraph(A7[0],A7[1],S2b[0],S2b[1])

print("\nCâu c: Slu with l = 1 and u = -1")
print(Slu(A7,1,-1))
S1c = Slu(A7,1,-1)
plotGraph(A7[0],A7[1],S1c[0],S1c[1])

print("----------")

print(Slu(B7,1,-1))
S2c = Slu(B7,1,-1)
plotGraph(A7[0],A7[1],S2c[0],S2c[1])

print("\nCâu d: Slu with l = -1 and u = 1")
print(Slu(A7,-1,1))
S1d = Slu(A7,-1,1)
plotGraph(A7[0],A7[1],S1d[0],S1d[1])
print("----------")
print(Slu(B7,-1,1))
S2d = Slu(B7,-1,1)
plotGraph(A7[0],A7[1],S2d[0],S2d[1])

"""# **Exercise 8:**"""

import numpy as np
from matplotlib import pyplot as plt
from sympy import *
def R(p,t):
    S = np.array([[np.cos(t),-np.sin(t)],[np.sin(t),np.cos(t)]])
    return S.dot(p)

def plotGraph(x1,y1,x2,y2):
    plt.plot(x1,y1,'ko',color = 'c')
    plt.plot(x2,y2,'ko',color = 'g')
    plt.grid()
    plt.show()

print("Câu a:")
A8 = np.array([1,-1])
A8Ra = R(A8,np.pi)
print(A8Ra)
plotGraph(A8[0],A8[1],A8Ra[0],A8Ra[1])
print("--------------\n")

print("Câu b:")
A8Rb = R(A8,np.pi/3)
print(A8Rb)
plotGraph(A8[0],A8[1],A8Rb[0],A8Rb[1])

"""# **Exercise 9:**"""

import numpy as np
from matplotlib import pyplot as plt
from sympy import *
#Vẽ đường thẳng qua 2 điểm P1(x1,y1) và P2(x2,y2)
#x, y = [x1, x2], [y1, y2]
#plt.plot(x, y, marker = 'o')
def PlotLine(P1,P2):
    x, y = [P1[0], P2[0]], [P1[1], P2[1]]
    plt.plot(x, y, marker = 'o')

def PlotHouse(A,B,C,D,E,F,G,H):
    PlotLine(A,B)
    PlotLine(B,C)
    PlotLine(C,D)
    PlotLine(D,E)
    PlotLine(E,F)
    PlotLine(F,G)
    PlotLine(G,H)
    PlotLine(H,A)


A = np.array([0,2])
B = np.array([1,3])
C = np.array([5,3])
D = np.array([6,2])
E = np.array([5,2])
F = np.array([5,0])
G = np.array([1,0])
H = np.array([1,2])


#Câu a: Translation with tx = 2 and ty = 4
print("Câu a:")

def PlotTrans(P1,P2,tx,ty):
    x, y = [P1[0] + tx, P2[0] + tx], [P1[1] + ty, P2[1] + ty]
    plt.plot(x, y, marker = 'o')

PlotHouse(A,B,C,D,E,F,G,H)
dx = 2
dy = 4
PlotTrans(A,B,dx,dy)
PlotTrans(B,C,dx,dy)
PlotTrans(C,D,dx,dy)
PlotTrans(D,E,dx,dy)
PlotTrans(E,F,dx,dy)
PlotTrans(F,G,dx,dy)
PlotTrans(G,H,dx,dy)
PlotTrans(H,A,dx,dy)
plt.show()

print("Câu b:")

def PlotRotation(P1,P2,alpha):
    #Cho tọa độ 2 điểm P1, P2, tìm P'1, P'2 qua góc quay alpha
    #x' = x*cos(t) - y*sin(t); y' = x*sin(t) + y*cos(t)
    x1 = P1[0]*cos(alpha) - P1[1]*sin(alpha)
    y1 = P1[0]*sin(alpha) + P1[1]*cos(alpha)
    
    x2 = P2[0]*cos(alpha) - P2[1]*sin(alpha)
    y2 = P2[0]*sin(alpha) + P2[1]*cos(alpha)
    x, y = [x1, x2], [y1, y2]
    plt.plot(x, y, marker = 'o')

PlotHouse(A,B,C,D,E,F,G,H)
t = pi/3
PlotRotation(A,B,t)
PlotRotation(B,C,t)
PlotRotation(C,D,t)
PlotRotation(D,E,t)
PlotRotation(E,F,t)
PlotRotation(F,G,t)
PlotRotation(G,H,t)
PlotRotation(H,A,t)
plt.show()

print("Câu c:")

def PlotScaling(P1,P2,sx,sy):
    x, y = [P1[0] / sx, P2[0] / sx], [P1[1] / sy, P2[1] / sy]
    plt.plot(x, y, marker = 'o')

PlotHouse(A,B,C,D,E,F,G,H)
sx = 2
sy = 4
PlotScaling(A,B,sx,sy)
PlotScaling(B,C,sx,sy)
PlotScaling(C,D,sx,sy)
PlotScaling(D,E,sx,sy)
PlotScaling(E,F,sx,sy)
PlotScaling(F,G,sx,sy)
PlotScaling(G,H,sx,sy)
PlotScaling(H,A,sx,sy)
plt.show()

print("Câu d:")

def PlotShearX(P1,P2,shearx):
    x,y = [P1[0] + shearx*P1[1], P2[0] + shearx*P2[1]], [P1[1] , P2[1]]
    plt.plot(x,y,marker = 'o')

def PlotShearY(P1,P2,sheary):
    x,y = [P1[0], P2[0]], [sheary*P1[0] + P1[1] , sheary*P2[0] + P2[1]]
    plt.plot(x,y,marker = 'o')
print("Shear along x with Shearx = 0.5:")
PlotHouse(A,B,C,D,E,F,G,H)
plt.show()
shearx = 0.5
PlotShearX(A,B,shearx)
PlotShearX(B,C,shearx)
PlotShearX(C,D,shearx)
PlotShearX(D,E,shearx)
PlotShearX(E,F,shearx)
PlotShearX(F,G,shearx)
PlotShearX(G,H,shearx)
PlotShearX(H,A,shearx)
plt.show()

print("\n--------------------------------\n")
print("Shear along y with Sheary = -1.5:")
PlotHouse(A,B,C,D,E,F,G,H)
plt.show()
sheary = -1.5
PlotShearY(A,B,sheary)
PlotShearY(B,C,sheary)
PlotShearY(C,D,sheary)
PlotShearY(D,E,sheary)
PlotShearY(E,F,sheary)
PlotShearY(F,G,sheary)
PlotShearY(G,H,sheary)
PlotShearY(H,A,sheary)
plt.show()

"""## **Exercise 10:**"""

import numpy as np
from matplotlib import pyplot as plt
from sympy import *
def PlotLine(P1,P2):
    x, y = [P1[0], P2[0]], [P1[1], P2[1]]
    plt.plot(x, y, marker = 'o')

A10 = np.array([[1,1], [3,1], [1,3]])
#-IA => I = 3*3
I3 = np.eye(3)
_IA = -(I3.dot(A10))
# print(_IA)

A = A10[0,:]
B = A10[1,:]
C = A10[2,:]
PlotLine(A,B) #Dòng 0 của ma trận A10
PlotLine(B,C)
PlotLine(C,A)

A1 = _IA[0,:]
B1 = _IA[1,:]
C1 = _IA[2,:]
PlotLine(A1,B1)
PlotLine(B1,C1)
PlotLine(C1,A1)

