# -*- coding: utf-8 -*-
"""52100841_NguyenTanThanh.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11HSZIM9NSfs7HKTPW6P1ryhMaj9Aj0nV
"""

import scipy.io
import os
import matplotlib.pyplot  as plt
import numpy as np


os.getcwd() # thu muc hien tai
# os.chdir("/content/drive/My Drive/ColabNottebooks/")
data = scipy.io.loadmat('./data.mat')

def load_ghost(plt,P,le,re,m,xt,yt,c_p,c_e,c_m,c_t,text):
    plt.plot(P[0, :], P[1, :],c_p)
    plt.plot(le[0, :], le[1, :],c_e)
    plt.plot(re[0, :], re[1, :],c_e)
    plt.plot(m[0, :], m[1, :],c_m)
    # plt.plot(xt, yt,c_t)
    # plt.text(xt, yt, text, fontsize=14, color=c_t)
    plt.plot(xt,yt,text, bbox = dict(facecolor=c_t, alpha=0.8))

# draw
# fig = plt.figure()
# ax = fig.add_subplot(111)
# ax.patch.set_facecolor('pink')
# plt = load_ghost(plt,data['P'],data['le'],data['re'],data['m'],data['xt'],data['yt'],data['c_p'],data['c_e'],data['c_m'],data['c_t'])

# plt.xlim(0, 1)
# plt.ylim(0, 1)

# plt.grid()
# plt.show()


def basic_translation(P,dx,dy):
    P_t = P.copy()
    P_t[0, :] = P[0, :] + dx
    P_t[1, :] = P[1, :] + dy
    return P_t

def translation(P,le,re,m,xt,yt):
    dx = 20
    dy = 0
    P_t = basic_translation(P,dx,dy)
    le_t = basic_translation(le,dx,dy)
    re_t = basic_translation(re,dx,dy)
    m_t = basic_translation(m,dx,dy)
    xt_t = xt + dx
    yt_t = yt + dy
    return P_t,le_t,re_t,m_t,xt_t,yt_t

def basic_shearing(P,sx,sy):
    M = np.array([[1,sx,0],[sy,1,0],[0,0,1]])
    Ps = np.zeros((P.shape), dtype=np.float32)
    for i in range(P.shape[1]):
        Pc = [P[0,i], P[1,i]]@M
        Ps[0,i] = Pc[0]
        Ps[1,i] = Pc[1]
    return Ps

def shearing(P,le,re,m,xt,yt):
    sx = 0.5
    sy = 0
    Ps = basic_shearing(P,sx,sy)
    le_s = basic_shearing(le,sx,sy)
    re_s = basic_shearing(re,sx,sy)
    m_s = basic_shearing(m,sx,sy)
    xt_s = xt
    yt_s = yt
    return Ps,le_s,re_s,m_s,xt_s,yt_s

def basic_scaling(P,sx,sy):
    M = np.array([[sx,0,0],[0,sy,0],[0,0,1]])
    Ps = np.zeros((P.shape), dtype=np.float32)
    for i in range(P.shape[1]):
        Pc = [P[0,i], P[1,i]]@M
        Ps[0,i] = Pc[0]
        Ps[1,i] = Pc[1]
    return Ps

def scaling(P,le,re,m,xt,yt):
    sx = 0.5
    sy = 0.5
    Ps = basic_scaling(P,sx,sy)
    le_s = basic_scaling(le,sx,sy)
    re_s = basic_scaling(re,sx,sy)
    m_s = basic_scaling(m,sx,sy)
    xt_s = xt
    yt_s = yt
    return Ps,le_s,re_s,m_s,xt_s,yt_s

def basic_reflection(P):
    M = np.array([[-1,0,0],[0,1,0],[0,0,1]])
    Ps = np.zeros((P.shape), dtype=np.float32)
    for i in range(P.shape[1]):
        Pc = [P[0,i], P[1,i]]@M
        Ps[0,i] = Pc[0]
        Ps[1,i] = Pc[1]
    return Ps

def reflection(P,le,re,m,xt,yt):
    Ps = basic_reflection(P)
    le_r = basic_reflection(le)
    re_r = basic_reflection(re)
    m_r = basic_reflection(m)
    xt_r = xt
    yt_r = yt
    return Ps,le_r,re_r,m_r,xt_r,yt_r

def basic_rotation(P,alpha):
    M = np.array([[np.cos(alpha),-np.sin(alpha),0],[np.sin(alpha),np.cos(alpha),0],[0,0,1]])
    Ps = np.zeros((P.shape), dtype=np.float32)
    for i in range(P.shape[1]):
        Pc = [P[0,i], P[1,i]]@M
        Ps[0,i] = Pc[0]
        Ps[1,i] = Pc[1]
    return Ps

def rotation(P,le,re,m,xt,yt):
    alpha = np.pi/4
    Ps = basic_rotation(P,alpha)
    le_r = basic_rotation(le,alpha)
    re_r = basic_rotation(re,alpha)
    m_r = basic_rotation(m,alpha)
    xt_r = xt
    yt_r = yt
    return Ps,le_r,re_r,m_r,xt_r,yt_r




# draw

fig = plt.figure()
ax = fig.add_subplot(111)
ax.patch.set_facecolor('pink')

load_ghost(plt,data['P'],data['le'],data['re'],data['m'],data['xt'],data['yt'],data['c_p'],data['c_e'],data['c_m'],data['c_t'],data['text'])

# affine transformation
P_t,le_t,re_t,m_t,xt_t,yt_t = translation(data['P'],data['le'],data['re'],data['m'],data['xt'],data['yt'])
load_ghost(plt,P_t,le_t,re_t,m_t,xt_t,yt_t,data['c_p'],data['c_e'],data['c_m'],data['c_t'],data['text'])

# shearing
Ps_t,le_s,re_s,m_s,xt_s,yt_s = shearing(data['P'],data['le'],data['re'],data['m'],data['xt'],data['yt'])
load_ghost(plt,Ps_t,le_s,re_s,m_s,xt_s,yt_s,data['c_p'],data['c_e'],data['c_m'],data['c_t'],data['text'])

# scaling
Ps_s,le_s,re_s,m_s,xt_s,yt_s = scaling(data['P'],data['le'],data['re'],data['m'],data['xt'],data['yt'])
load_ghost(plt,Ps_s,le_s,re_s,m_s,xt_s,yt_s,data['c_p'],data['c_e'],data['c_m'],data['c_t'],data['text'])

# reflection
Ps_r,le_r,re_r,m_r,xt_r,yt_r = reflection(data['P'],data['le'],data['re'],data['m'],data['xt'],data['yt'])
load_ghost(plt,Ps_r,le_r,re_r,m_r,xt_r,yt_r,data['c_p'],data['c_e'],data['c_m'],data['c_t'],data['text'])

# rotation
Ps_r,le_r,re_r,m_r,xt_r,yt_r = rotation(data['P'],data['le'],data['re'],data['m'],data['xt'],data['yt'])
load_ghost(plt,Ps_r,le_r,re_r,m_r,xt_r,yt_r,data['c_p'],data['c_e'],data['c_m'],data['c_t'],data['text'])





# load
plt.xlim(0, 1)
plt.ylim(0, 1)

plt.grid()
plt.show()

from google.colab.patches import cv2_imshow
import numpy as np
from PIL import Image

im = Image.open('testdata/test.jpg')
plt.imshow(im)
im_g = np.asanyarray(im)

U, S, V  = np.linalg.svd(im_g,full_matrices=True)
s = np.diag(S)

for r in range(2,200,50):
    R = U[:,:r] @ s[:r,:r] @ V[:r,:]
    plt.imshow(R,cmap = 'gray')
    plt.title('r = ' + str(r))
    plt.plot()
    plt.pause(0.01)
    plt.clf()
    R = R.astype(np.uint8)
    compressed_image = Image.fromarray(R)
    compressed_image.save('testdata/compressed_image_' + str(r) + '.jpg')

import matplotlib.pyplot  as plt
import numpy as np

import numpy as np
import matplotlib.pyplot as plt

def findTheEigenvalues(A):
    """
    Finds the eigenvalues of a matrix A
    """
    eigenvalues = []
    for i in range(len(A)):
        eigenvalues.append(A[i][i])
    return eigenvalues

def computeDeterminantBasedOnEigenvalues(eigenvalues):
    """
    Computes the determinant of a matrix based on its eigenvalues
    """
    determinant = 1
    for i in range(len(eigenvalues)):
        determinant *= eigenvalues[i]
    return determinant

A = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
eigenvalues = findTheEigenvalues(A)
determinant = computeDeterminantBasedOnEigenvalues(eigenvalues)
print("The determinant of the matrix A is:", determinant)

import numpy as np

A1 = np.array([[1,0],[0,3]])

def FindTheSingularValue(A):
    # Find the singular value of a matrix
    # A: a matrix
    # return: the singular value of A
    U,S,V = np.linalg.svd(A)
    return S[0]

import numpy as np

A1 = np.array([[-18,13,-4,4],[2,3,5,-5],[1,4,-5,6],[3,4,5,4]])



def computeSVD(A):
    # Compute the SVD of a matrix
    # A: a matrix
    # return: U,S,V
    U,S,V = np.linalg.svd(A)
    return U,S,V

import numpy as np
import cv2

img = cv2.imread('lena.jpg')

cv2.imshow('original', img)
cv2.waitKey(0)